1111

## 第一章

### 1.3 🌟 时延计算

![image-20190112151357355](./assets/image-20190112151357355.png)

1. 处理时延
2. 排队时延
   1. 在链路上等待传输时，经受 __排队时延__
3. 传播时延
   1. 先到先服务方式传输，传输时延是 L / R
   2. R (b/s) 表示从路由器A到路由器B的链路传输速率
   3. L (bit) 表示该分组的长度
4. 传输时延
   1. 从链路起点到路由器传播所需要的时间，取决于该链路的物理媒体
   2. d / s
   3. d : 路由器之间的距离
   4. s : 该链路的传播速率

作业题目：



### 1.4 🌟 分层的体系结构

1. 应用层
   * http
2. 运输层
   * tcp / ip
   * 可靠数据传输协议
3. 网络层
   * ip地址
   * 路由选择算法
4. 链路层
   * 多路访问链路和协议
   * 随机接入协议
   * ARP
5. 物理层



## 第二章 应用层

### 2.1 应用层协议原理

#### 1.应用程序体系结构

客户-服务器体系结构 / P2P体系结构

#### 2. C/S结构特征

* 具有固定的、周知的地址   -- ip地址

#### 3. p2p结构特征

* 自扩展性

#### 4. 进程与计算机网络之间的接口

1. 通过 __套接字__ 的软件接口向网络发送报文和从网络接收报文
2. 套接字是应用程序进程和运输层协议之间的接口
3. 套接字也成为应用程序和网络之间的应用程序编程接口
4. 使用IP地址标识主机，同时应当指定运行在接收主机上的接收进程（接收套接字）。一般使用 __目的地端口号__ 实现这个目的

#### 5. 可供应用程序使用的运输服务

一个运输层协议能够为调用它的应用程序提供什么样的服务呢？从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时、安全性

1. 可靠数据传输
   * 确保由应用程序一端发送的数据正确、完全地交付给该应用程序的另一端
   * 由运输层协议提供
   * 将数据传递给套接字之后就可以完全放心不用管啦
   * 当不提供可靠数据传输时，可能能被容忍丢失的应用所接受
2. 吞吐量
   * 可用吞吐量就是发送进程能够向接收进程交付比特的速率
3. 定时
4. 安全性
   * 运输协议能够加密由发送进程传输的所有数据

####  6. 因特网提供的运输服务

1. 因特网为应用程序提供两个运输层协议：TCP / UDP
2. TCP服务
   * 面向连接的服务（握手）
   * 可靠的数据传送服务
   * 具有拥塞控制机制
   * TCP安全性：使用 __安全套接字层__ ，在应用层上实现的加强。
   * 发送进程  ---(明文数据)--> SSL套接字 ---(加密数据)---> TCP套接字
3. UDP服务
   * 不提供不必要服务的轻量级协议
   * 无连接（不握手😢），不可靠🙅数据传送服务

#### 7. 应用层协议

如何构造报文？各个字段含义？何时发送报文？

__应用层协议__ 定义了运行在不同端系统上的应用程序进程如何相互传递报文

* 交换的报文类型
* 报文类型的语法
* 字段的语义
* 一个进程何时以及如何发送报文



### 2.2 Web

#### 2.2.1 🌟 HTTP概况（应用层协议）

1. http使用TCP作为支撑运输协议
2. http不保存关于客户的任何信息，是个无状态协议
3. Web使用了 C/S 应用程序体系结构

#### 2.2.2 非持续连接和持续连接

1. 持续连接：所有请求及其响应经相同的TCP链接发送

2. 非持续连接：请求/响应对 经一个单独的TCP连接发送

3. 端口号：80 🌟

4. 非持续连接情况下，从服务器向客户传送一个Web页面的步骤

   ![image-20190112151415889](./assets/image-20190112151415889.png)

5. 客户请求HTML基本文件起到客户收到整个文件所花费时间

   * 往返时间定义：一个短分组从客户到服务器然后再返回客户所花费的时间

     ![image-20190112151425086](./assets/image-20190112151425086.png)

6. 采用持续的连接

   * 为每一个请求的对象建立和维护一个全新的连接



#### 2.2.3 报文格式

两种报文：请求报文和响应报文

1. 请求报文

   ![image-20190112151434475](./assets/image-20190112151434475.png)

   * 第一行：请求行（方法字段，URL字段，HTTP版本字段）
   * 之后的行：首部行
     * Host：指明对象所在的主机
     * Connection: close，不用使用持续连接
     * User-agent：指明用户代理，向服务器发送请求的浏览器的类型
     * Accept-language：语言版本 / 默认版本

2. 响应报文

   ![image-20190112151441166](./assets/image-20190112151441166.png)

   * 初始状态行（协议版本字段，状态码，相关状态信息）
   * 首部行
     * Connection: close：发送完报文后会关闭连接
     * Date：指示服务器产生并发送该响应报文的日期和时间
     * Server：服务器类型
     * Last-Modified：最后修改时间
     * Content-Length：被发送对象中的字节数
     * Content-Type：实体对象类型
   * 实体体（报文的主要部分，包含了所请求的对象本身）

 

### 2.5 DNS

#### 2.5.1 DNS提供的服务

![image-20190112151503650](./assets/image-20190112151503650.png)



### 2.6 P2P应用

1. 基本工作机制
   * 向邻居请求哪些块（最稀罕优先）
   * 优先响应哪些请求（对换算法 4+1）
2. 对换算法
   * 每10秒确定前4个最高速率对等方
   * 每30秒随机选择一个新邻居



## 第三章 运输层

运输层位于应用层和网络层之间，该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。

功能：

* 将网络层的在两个端系统之间的交互服务扩展到运行在两个不同端系统上的应用层进程之间的交付服务。
* 两个实体如何在会丢失或者损坏数据的媒体上可靠地通信

### 3.1 概述和运输层服务

运输层协议是在端系统而不是在路由器中实现的。发送端将从应用程序进程接收到的报文转换成运输层分组（即为运输层报文段），然后将报文段交给网络层，网络层将其分装成网络层分组（即为数据报）并向目的地发送。

运输层协议：TCP（传输控制协议）， UDP（用户数据报协议）。

### 3.2 多路分解，多路复用

1. 将主机间交互扩展到进程间交付被称为运输层的多路分解和多路复用
2. 通过 __源端口号字段__和__目的端口号字段__ 实现运输层的分解服务，

![image-20190112151344752](./assets/image-20190112151344752.png)

3.3 无连接传输：UDP

1. 无拥塞控制
2. 无需建立连接
3. 无连接状态
4. 分组首部开销小

![image-20190112151327394](./assets/image-20190112151327394.png)

### 3.4 🌟 可靠数据传输原理

#### 3.4.1 构造协议 rdt 的一步步推进

1. rdt1.0

   ![image-20190112151517516](./assets/image-20190112151517516.png)

2. Rdt2.0

   * 使用了肯定确认和否定确认，基于这样重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议
     * 差错检测（判断分组受损）
     * 接收方反馈（ACK / NAK）
     * 重传（收到有差错的分组）
   * __停等协议__
   * 使用序号保证应答正确

3. rdt3.0

   * 重传：倒计时定时器（比一个rtt长一点）
   * 检验和 
   * 序号
   * ACK

![image-20190112154323563](assets/image-20190112154323563.png)

![image-20190112154553910](assets/image-20190112154553910.png)



#### 3.4.2 流水线

##### (1) 计算信道利用率

发送方（信道）利用率：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比。

以停等操作的发送方利用率计算为例：

![image-20190112154804032](assets/image-20190112154804032.png)

##### (2) 使用流水线操作

U = $(3 * L/R) / ( RTT + L / R ) $

![image-20190112155008163](assets/image-20190112155008163.png)



* 增加序号范围
* 也许需要缓存多个分组
* 解决流水线的差错恢复有两种基本方法：__回退N步__（GBN） 和 __选择重传__（SR）



#### 3.4.3 🌟 回退N步

![image-20190112155228996](assets/image-20190112155228996.png)

* N 窗口长度
* GBN协议：滑动窗口协议

##### (1) 发送方的扩展FSM描述注意点

1. 滑动窗口判断发送数据
   - 定时器在发送数据时只开启一个
2. 重启定时器的时机
   - 是否发出的数据全部收到ACK
3. 收到ACK的时候
   - 因为是按序，所以直接`base = getacknum(rcvpkt) + 1`
4. 超时
   - 只要超时，一定是base超时，直接重启定时器
   - 一下子将窗口里的所有数据重发



![image-20190112155355290](assets/image-20190112155355290.png)



##### (2) 接收方的扩展FSM描述注意点

1. 收到报文需要进行报文检验
   * 出错直接发送回应
2. 收到报文时检查序号
   * 序号不正确直接退回
   * 否则返回ACK（累计确认返回已正确收到的序号的最大值），将本地的expectedseqnum++
3. 采用 🌟__累计确认__ 的方式，表示接收方已经正确收到序号为n的以前且包括 n 在内的所有分组

![image-20190112160044218](assets/image-20190112160044218.png)



##### (3) 运行中的GBN

![image-20190112160327156](assets/image-20190112160327156.png)



#### 3.4.4 🌟 选择重传

![image-20190112163817868](assets/image-20190112163817868.png)

##### (1) 发送方的事件及动作

1. 超时
   * 每个分组拥有其自己的定时器
2. 收到ACK
   * 如果在窗口内，则将那个确认的分组标记为已接收
   * 如果序号 = send_base，则将窗口基序号移动到后面的最小序号处。
   * 如果窗口移动了并且有序号落在窗口内的未发送分组，则发送

![image-20190112164653172](assets/image-20190112164653172.png)

##### (2) 接收方的事件及动作

1. 失序的分组将被缓存知道所有丢失分组（比序号更小的分组）皆被收到为止

![image-20190112164641164](assets/image-20190112164641164.png)

##### (3) 运行中的SR协议

![image-20190112164632293](assets/image-20190112164632293.png)



### 3.5 🌟🌟 面向连接的运输：TCP

#### 3.5.1 TCP连接

1. 面向连接，两个进程必须先相互 “握手” 🤝

   * 三次握手

     ![image-20190112165703287](assets/image-20190112165703287.png)

   * 协商

     * x, y
     * MSS
     * 分配资源

2. 提供全双工服务，点对点

3. MSS：最大报文段长度

4. MTU：最大传输单元

5. 当TCP为每块客户数据配上一个TCP首部时，形成了多个TCP报文段



#### 3.5.2 🌟 TCP报文段结构

![image-20190112171849405](assets/image-20190112171849405.png)

1. `16bit`源端口号/`16bit`目的端口号
   * 用于多路分解/复用
2. `32bit` 序号，用于实现可靠数据传输服务
3. `32bit` 确认号，用于实现可靠数据传输服务
4. `4bit` 的首部长度 + 保留未用的 6bit 数据
5. `6bit` 的标志字段
6. `16bit` 接收窗口字段，用于指示接收方愿意接受的字节数量
7. 检验和 + 紧急数据指针
8. 可选和变长的`选项字段`，一般用于双方协商最大报文段长度（MSS）时使用
   * 长度可变 + 填充（最后两位）为了填充为4个字节



##### (1) 经TCP的简单的Telnet应用的确认号和序号

![image-20190112204533765](assets/image-20190112204533765.png)

* 需要计算数据长度

#### 3.5.3 往返时间的估计和超时

1. 估计往返时间

   * 首先计算 EstimatedRTT

   ![image-20190112205517223](assets/image-20190112205517223.png)

   * 计算DevRTT，![image-20190112205653387](assets/image-20190112205653387.png) 的推荐值 = 0.25

   ![image-20190112205633933](assets/image-20190112205633933.png)

   * 计算重传超时间隔
     * TimeoutInterval = EstimatedRTT + 4 * DevRTT

#### 3.5.4 可靠数据传输

##### (1) 讨论TCP如何提供可靠数据传输

三个与发送和重传的主要事件：

1. 从上层应用数据接收数据
2. 定时器超时（过期间隔是TimeoutInterval）
3. 收到ACK
   * 将ACK的`y` 值与`sendBase`进行比较。sendBase是最早未被确认的字节的序号。确认号代表期望收到的下一个序号，且之前所有数据均被接收

简化的TCP发送方

![image-20190112210329948](assets/image-20190112210329948.png)

##### (2) 超时间隔加倍

每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是TimeoutInterval。

但是当正常情况下只会是TimeoutInterval

##### (3) 🌟 快速重传

通过重复的ACK检测丢失报文段

![image-20190112211407633](assets/image-20190112211407633.png)

如果TCP发送方接收到对相同数据的3个冗余ACK，就立刻执行快速重传。

##### (4) 回退N步还是选择重传

更像是二者的结合体



##### 3.5.5 流量控制

流量控制服务：用于消除发送方使接收方缓存溢出的可能性。

流量控制是一个速度匹配服务，即发送方的发送速率与接收方的应用程序的读取速率相匹配。

1. 发送方维持一个 __接收窗口__的变量来提供流量控制。
2. TCP提供流量控制，但是UDP并不提供哦🙅



#### 3.5.6 TCP连接管理

1. TCP三次握手的报文段交换

![image-20190112212133925](assets/image-20190112212133925.png)



### 3.6 拥塞控制

过多的源发送了过多的数据



### 3.7 🌟🌟 TCP拥塞控制

##### (1) 慢启动（无历史信息）

1. cwnd的值通常设置为一个MSS的较小值
2. 初始发送速率大约为 $ MSS / RTT $



![image-20190112212804641](assets/image-20190112212804641.png)

* 慢启动状态下，每经过一个RTT，发送速率翻番。



⚠️⚠️ 何时结束这种指数级增长❓

1. 存在一个由超时知识的丢包事件（拥塞），cwnd设置为1，同时重新开始慢启动。而同时将阈值`ssthresh` 设置为 `cwnd / 2`。

   ```
   ssthresh = cwnd / 2
   cwnd = 1 MSS
   ```

2. 当cwnd的值 等于 `ssthresh` 时，结束慢启动并且TCP转移到拥塞避免模式

3. 检测到 3 个冗余ACK，执行一种快速重传。此时判定为丢了 -> `ssthresh` 设为 `cwnd / 2 ` ，`cwnd` 设为 ` ssthresh 再加 3 个MSS` -> 线性增大

   ```
   ssthresh = cwnd / 2
   cwnd = ssthresh + 3MSS
   ```

##### (2) 拥塞避免

进入拥塞避免时，开始 `线性` 增长 ❗️

何时结束呢❓

1. 当出现超时时
   * cwnd = 1 MSS
2. 当出现丢包
   * ssthresh = cwnd / 2
   * cwnd = ssthresh + 3



##### (3) 快速恢复

1. Tahoe：
   * 无论发生超时的丢包 还是 3个冗余ACK的丢包，统统无条件地将cwnd减为1个MSS，并进入慢启动阶段
2. Reno版本：

两种版本不同的拥塞窗口的变化

![image-20190112214247335](assets/image-20190112214247335.png)



#####  作业题 ❤️❤️❤️ Reno / Tahoe

![image-20190112214459782](assets/image-20190112214459782.png)

1. 慢启动： [ 1, 6 ], [ 23, 26 ]
2. 拥塞避免运行：[ 6, 16 ], [ 17, 22] 
3. 第 16 个后，报文段的丢失是 3 个冗余ACK
4. 第 22 个后，报文段的丢失是超时
5. 第1 个中，ssthresh = 32
6. 第 18 个中，ssthresh = 42 / 2 = 21 （❗️3个冗余ACK导致的应该是cwnd / 2）
7. 第 24 个中，ssthresh = 29 / 2 = 14 （❗️超时导致的也是 cwnd / 2）
8. 第 70 个报文段 ：第7个
9. 3个冗余ACK：ssthresh = 8 / 2 = 4，cwnd = 4 + 3 = 7
10. 使用 Tahoe（❗️无论什么原因都直接从头开始，ssthresh = cwnd / 2），16收到了3个冗余ACK，cwnd = 4 
11. 请注意新的阈值



##### (4) TCP拥塞控制：回顾

1. 每个RTT内cwnd线性增加，出现3个冗余ACK后，cwnd减半。
2. 加性增，乘性减 的拥塞控制方式

##### (5) 吞吐量

![image-20190112220315873](assets/image-20190112220315873.png)



## 第四章 网络层

网络层是如何实现主机到主机的通信服务。

主要内容：

1. 分组转发
2. 路由选择
3. ipv4
4. IP
5. NAT
6. 数据报分段（网络地址转换）
7. 因特网控制报文协议





## 第五章：链路层

![image-20190112230728378](assets/image-20190112230728378.png)

![image-20190112230738580](assets/image-20190112230738580.png)

### 5.1 链路层概述



#### test

#### test